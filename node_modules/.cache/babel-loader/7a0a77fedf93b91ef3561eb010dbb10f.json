{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global['fast-copy'] = factory());\n})(this, function () {\n  'use strict';\n\n  var toStringFunction = Function.prototype.toString;\n  var create = Object.create,\n      defineProperty = Object.defineProperty,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n      getOwnPropertyNames = Object.getOwnPropertyNames,\n      getOwnPropertySymbols = Object.getOwnPropertySymbols,\n      getPrototypeOf = Object.getPrototypeOf;\n  var _a = Object.prototype,\n      hasOwnProperty = _a.hasOwnProperty,\n      propertyIsEnumerable = _a.propertyIsEnumerable;\n  /**\r\n   * @enum\r\n   *\r\n   * @const {Object} SUPPORTS\r\n   *\r\n   * @property {boolean} SYMBOL_PROPERTIES are symbol properties supported\r\n   * @property {boolean} WEAKMAP is WeakMap supported\r\n   */\n\n  var SUPPORTS = {\n    SYMBOL_PROPERTIES: typeof getOwnPropertySymbols === 'function',\n    WEAKMAP: typeof WeakMap === 'function'\n  };\n  /**\r\n   * @function createCache\r\n   *\r\n   * @description\r\n   * get a new cache object to prevent circular references\r\n   *\r\n   * @returns the new cache object\r\n   */\n\n  var createCache = function () {\n    if (SUPPORTS.WEAKMAP) {\n      return new WeakMap();\n    } // tiny implementation of WeakMap\n\n\n    var object = create({\n      has: function (key) {\n        return !!~object._keys.indexOf(key);\n      },\n      set: function (key, value) {\n        object._keys.push(key);\n\n        object._values.push(value);\n      },\n      get: function (key) {\n        return object._values[object._keys.indexOf(key)];\n      }\n    });\n    object._keys = [];\n    object._values = [];\n    return object;\n  };\n  /**\r\n   * @function getCleanClone\r\n   *\r\n   * @description\r\n   * get an empty version of the object with the same prototype it has\r\n   *\r\n   * @param object the object to build a clean clone from\r\n   * @param realm the realm the object resides in\r\n   * @returns the empty cloned object\r\n   */\n\n\n  var getCleanClone = function (object, realm) {\n    if (!object.constructor) {\n      return create(null);\n    }\n\n    var Constructor = object.constructor;\n    var prototype = object.__proto__ || getPrototypeOf(object);\n\n    if (Constructor === realm.Object) {\n      return prototype === realm.Object.prototype ? {} : create(prototype);\n    }\n\n    if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n      try {\n        return new Constructor();\n      } catch (_a) {}\n    }\n\n    return create(prototype);\n  };\n  /**\r\n   * @function getObjectCloneLoose\r\n   *\r\n   * @description\r\n   * get a copy of the object based on loose rules, meaning all enumerable keys\r\n   * and symbols are copied, but property descriptors are not considered\r\n   *\r\n   * @param object the object to clone\r\n   * @param realm the realm the object resides in\r\n   * @param handleCopy the function that handles copying the object\r\n   * @returns the copied object\r\n   */\n\n\n  var getObjectCloneLoose = function (object, realm, handleCopy, cache) {\n    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively\n\n    cache.set(object, clone);\n\n    for (var key in object) {\n      if (hasOwnProperty.call(object, key)) {\n        clone[key] = handleCopy(object[key], cache);\n      }\n    }\n\n    if (SUPPORTS.SYMBOL_PROPERTIES) {\n      var symbols = getOwnPropertySymbols(object);\n      var length_1 = symbols.length;\n\n      if (length_1) {\n        for (var index = 0, symbol = void 0; index < length_1; index++) {\n          symbol = symbols[index];\n\n          if (propertyIsEnumerable.call(object, symbol)) {\n            clone[symbol] = handleCopy(object[symbol], cache);\n          }\n        }\n      }\n    }\n\n    return clone;\n  };\n  /**\r\n   * @function getObjectCloneStrict\r\n   *\r\n   * @description\r\n   * get a copy of the object based on strict rules, meaning all keys and symbols\r\n   * are copied based on the original property descriptors\r\n   *\r\n   * @param object the object to clone\r\n   * @param realm the realm the object resides in\r\n   * @param handleCopy the function that handles copying the object\r\n   * @returns the copied object\r\n   */\n\n\n  var getObjectCloneStrict = function (object, realm, handleCopy, cache) {\n    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively\n\n    cache.set(object, clone);\n    var properties = SUPPORTS.SYMBOL_PROPERTIES ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object)) : getOwnPropertyNames(object);\n    var length = properties.length;\n\n    if (length) {\n      for (var index = 0, property = void 0, descriptor = void 0; index < length; index++) {\n        property = properties[index];\n\n        if (property !== 'callee' && property !== 'caller') {\n          descriptor = getOwnPropertyDescriptor(object, property);\n\n          if (descriptor) {\n            // Only clone the value if actually a value, not a getter / setter.\n            if (!descriptor.get && !descriptor.set) {\n              descriptor.value = handleCopy(object[property], cache);\n            }\n\n            try {\n              defineProperty(clone, property, descriptor);\n            } catch (error) {\n              // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n              clone[property] = descriptor.value;\n            }\n          } else {\n            // In extra edge cases where the property descriptor cannot be retrived, fall back to\n            // the loose assignment.\n            clone[property] = handleCopy(object[property], cache);\n          }\n        }\n      }\n    }\n\n    return clone;\n  };\n  /**\r\n   * @function getRegExpFlags\r\n   *\r\n   * @description\r\n   * get the flags to apply to the copied regexp\r\n   *\r\n   * @param regExp the regexp to get the flags of\r\n   * @returns the flags for the regexp\r\n   */\n\n\n  var getRegExpFlags = function (regExp) {\n    var flags = '';\n\n    if (regExp.global) {\n      flags += 'g';\n    }\n\n    if (regExp.ignoreCase) {\n      flags += 'i';\n    }\n\n    if (regExp.multiline) {\n      flags += 'm';\n    }\n\n    if (regExp.unicode) {\n      flags += 'u';\n    }\n\n    if (regExp.sticky) {\n      flags += 'y';\n    }\n\n    return flags;\n  }; // utils\n\n\n  var isArray = Array.isArray;\n\n  var GLOBAL_THIS = function () {\n    if (typeof self !== 'undefined') {\n      return self;\n    }\n\n    if (typeof window !== 'undefined') {\n      return window;\n    }\n\n    if (typeof global !== 'undefined') {\n      return global;\n    }\n\n    if (console && console.error) {\n      console.error('Unable to locate global object, returning \"this\".');\n    }\n  }();\n  /**\r\n   * @function copy\r\n   *\r\n   * @description\r\n   * copy an object deeply as much as possible\r\n   *\r\n   * If `strict` is applied, then all properties (including non-enumerable ones)\r\n   * are copied with their original property descriptors on both objects and arrays.\r\n   *\r\n   * The object is compared to the global constructors in the `realm` provided,\r\n   * and the native constructor is always used to ensure that extensions of native\r\n   * objects (allows in ES2015+) are maintained.\r\n   *\r\n   * @param object the object to copy\r\n   * @param [options] the options for copying with\r\n   * @param [options.isStrict] should the copy be strict\r\n   * @param [options.realm] the realm (this) object the object is copied from\r\n   * @returns the copied object\r\n   */\n\n\n  function copy(object, options) {\n    // manually coalesced instead of default parameters for performance\n    var isStrict = !!(options && options.isStrict);\n    var realm = options && options.realm || GLOBAL_THIS;\n    var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;\n    /**\r\n     * @function handleCopy\r\n     *\r\n     * @description\r\n     * copy the object recursively based on its type\r\n     *\r\n     * @param object the object to copy\r\n     * @returns the copied object\r\n     */\n\n    var handleCopy = function (object, cache) {\n      if (!object || typeof object !== 'object') {\n        return object;\n      }\n\n      if (cache.has(object)) {\n        return cache.get(object);\n      }\n\n      var Constructor = object.constructor; // plain objects\n\n      if (Constructor === realm.Object) {\n        return getObjectClone(object, realm, handleCopy, cache);\n      }\n\n      var clone; // arrays\n\n      if (isArray(object)) {\n        // if strict, include non-standard properties\n        if (isStrict) {\n          return getObjectCloneStrict(object, realm, handleCopy, cache);\n        }\n\n        var length_1 = object.length;\n        clone = new Constructor();\n        cache.set(object, clone);\n\n        for (var index = 0; index < length_1; index++) {\n          clone[index] = handleCopy(object[index], cache);\n        }\n\n        return clone;\n      } // dates\n\n\n      if (object instanceof realm.Date) {\n        return new Constructor(object.getTime());\n      } // regexps\n\n\n      if (object instanceof realm.RegExp) {\n        clone = new Constructor(object.source, object.flags || getRegExpFlags(object));\n        clone.lastIndex = object.lastIndex;\n        return clone;\n      } // maps\n\n\n      if (realm.Map && object instanceof realm.Map) {\n        clone = new Constructor();\n        cache.set(object, clone);\n        object.forEach(function (value, key) {\n          clone.set(key, handleCopy(value, cache));\n        });\n        return clone;\n      } // sets\n\n\n      if (realm.Set && object instanceof realm.Set) {\n        clone = new Constructor();\n        cache.set(object, clone);\n        object.forEach(function (value) {\n          clone.add(handleCopy(value, cache));\n        });\n        return clone;\n      } // blobs\n\n\n      if (realm.Blob && object instanceof realm.Blob) {\n        return object.slice(0, object.size, object.type);\n      } // buffers (node-only)\n\n\n      if (realm.Buffer && realm.Buffer.isBuffer(object)) {\n        clone = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(object.length) : new Constructor(object.length);\n        cache.set(object, clone);\n        object.copy(clone);\n        return clone;\n      } // arraybuffers / dataviews\n\n\n      if (realm.ArrayBuffer) {\n        // dataviews\n        if (realm.ArrayBuffer.isView(object)) {\n          clone = new Constructor(object.buffer.slice(0));\n          cache.set(object, clone);\n          return clone;\n        } // arraybuffers\n\n\n        if (object instanceof realm.ArrayBuffer) {\n          clone = object.slice(0);\n          cache.set(object, clone);\n          return clone;\n        }\n      } // if the object cannot / should not be cloned, don't\n\n\n      if ( // promise-like\n      typeof object.then === 'function' || // errors\n      object instanceof Error || // weakmaps\n      realm.WeakMap && object instanceof realm.WeakMap || // weaksets\n      realm.WeakSet && object instanceof realm.WeakSet) {\n        return object;\n      } // assume anything left is a custom constructor\n\n\n      return getObjectClone(object, realm, handleCopy, cache);\n    };\n\n    return handleCopy(object, createCache());\n  } // Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n  // expects there to be a default property on the exported object. See\n  // [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\n\n\n  copy.default = copy;\n  /**\r\n   * @function strictCopy\r\n   *\r\n   * @description\r\n   * copy the object with `strict` option pre-applied\r\n   *\r\n   * @param object the object to copy\r\n   * @param [options] the options for copying with\r\n   * @param [options.realm] the realm (this) object the object is copied from\r\n   * @returns the copied object\r\n   */\n\n  copy.strict = function strictCopy(object, options) {\n    return copy(object, {\n      isStrict: true,\n      realm: options ? options.realm : void 0\n    });\n  };\n\n  return copy;\n});","map":{"version":3,"sources":["../src/utils.ts","../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["const { toString: toStringFunction } = Function.prototype;\nconst {\n  create,\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getOwnPropertySymbols,\n  getPrototypeOf,\n} = Object;\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\n\n/**\n * @enum\n *\n * @const {Object} SUPPORTS\n *\n * @property {boolean} SYMBOL_PROPERTIES are symbol properties supported\n * @property {boolean} WEAKMAP is WeakMap supported\n */\nexport const SUPPORTS = {\n  SYMBOL_PROPERTIES: typeof getOwnPropertySymbols === 'function',\n  WEAKMAP: typeof WeakMap === 'function',\n};\n\n/**\n * @function createCache\n *\n * @description\n * get a new cache object to prevent circular references\n *\n * @returns the new cache object\n */\nexport const createCache = (): FastCopy.Cache => {\n  if (SUPPORTS.WEAKMAP) {\n    return new WeakMap();\n  }\n\n  // tiny implementation of WeakMap\n  const object = create({\n    has: (key: any) => !!~object._keys.indexOf(key),\n    set: (key: any, value: any) => {\n      object._keys.push(key);\n      object._values.push(value);\n    },\n    get: (key: any) => object._values[object._keys.indexOf(key)],\n  });\n\n  object._keys = [];\n  object._values = [];\n\n  return object;\n};\n\n/**\n * @function getCleanClone\n *\n * @description\n * get an empty version of the object with the same prototype it has\n *\n * @param object the object to build a clean clone from\n * @param realm the realm the object resides in\n * @returns the empty cloned object\n */\nexport const getCleanClone = (object: any, realm: FastCopy.Realm): any => {\n  if (!object.constructor) {\n    return create(null);\n  }\n\n  const { constructor: Constructor } = object;\n  const prototype = object.__proto__ || getPrototypeOf(object);\n\n  if (Constructor === realm.Object) {\n    return prototype === realm.Object.prototype ? {} : create(prototype);\n  }\n\n  if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n    try {\n      return new Constructor();\n    } catch {}\n  }\n\n  return create(prototype);\n};\n\n/**\n * @function getObjectCloneLoose\n *\n * @description\n * get a copy of the object based on loose rules, meaning all enumerable keys\n * and symbols are copied, but property descriptors are not considered\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneLoose: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = handleCopy(object[key], cache);\n    }\n  }\n\n  if (SUPPORTS.SYMBOL_PROPERTIES) {\n    const symbols: symbol[] = getOwnPropertySymbols(object);\n\n    const { length } = symbols;\n\n    if (length) {\n      for (let index = 0, symbol; index < length; index++) {\n        symbol = symbols[index];\n\n        if (propertyIsEnumerable.call(object, symbol)) {\n          clone[symbol] = handleCopy(object[symbol], cache);\n        }\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getObjectCloneStrict\n *\n * @description\n * get a copy of the object based on strict rules, meaning all keys and symbols\n * are copied based on the original property descriptors\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneStrict: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  const properties: (string | symbol)[] = SUPPORTS.SYMBOL_PROPERTIES\n    ? getOwnPropertyNames(object).concat((getOwnPropertySymbols(object) as unknown) as string[])\n    : getOwnPropertyNames(object);\n\n  const { length } = properties;\n\n  if (length) {\n    for (let index = 0, property, descriptor; index < length; index++) {\n      property = properties[index];\n\n      if (property !== 'callee' && property !== 'caller') {\n        descriptor = getOwnPropertyDescriptor(object, property);\n\n        if (descriptor) {\n          // Only clone the value if actually a value, not a getter / setter.\n          if (!descriptor.get && !descriptor.set) {\n            descriptor.value = handleCopy(object[property], cache);\n          }\n\n          try {\n            defineProperty(clone, property, descriptor);\n          } catch (error) {\n            // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n            clone[property] = descriptor.value;\n          }\n        } else {\n          // In extra edge cases where the property descriptor cannot be retrived, fall back to\n          // the loose assignment.\n          clone[property] = handleCopy(object[property], cache);\n        }\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getRegExpFlags\n *\n * @description\n * get the flags to apply to the copied regexp\n *\n * @param regExp the regexp to get the flags of\n * @returns the flags for the regexp\n */\nexport const getRegExpFlags = (regExp: RegExp): string => {\n  let flags = '';\n\n  if (regExp.global) {\n    flags += 'g';\n  }\n\n  if (regExp.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (regExp.multiline) {\n    flags += 'm';\n  }\n\n  if (regExp.unicode) {\n    flags += 'u';\n  }\n\n  if (regExp.sticky) {\n    flags += 'y';\n  }\n\n  return flags;\n};\n","// utils\nimport { createCache, getObjectCloneLoose, getObjectCloneStrict, getRegExpFlags } from './utils';\n\nconst { isArray } = Array;\n\nconst GLOBAL_THIS = (() => {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  if (console && console.error) {\n    console.error('Unable to locate global object, returning \"this\".');\n  }\n})();\n\n/**\n * @function copy\n *\n * @description\n * copy an object deeply as much as possible\n *\n * If `strict` is applied, then all properties (including non-enumerable ones)\n * are copied with their original property descriptors on both objects and arrays.\n *\n * The object is compared to the global constructors in the `realm` provided,\n * and the native constructor is always used to ensure that extensions of native\n * objects (allows in ES2015+) are maintained.\n *\n * @param object the object to copy\n * @param [options] the options for copying with\n * @param [options.isStrict] should the copy be strict\n * @param [options.realm] the realm (this) object the object is copied from\n * @returns the copied object\n */\nfunction copy<T>(object: T, options?: FastCopy.Options): T {\n  // manually coalesced instead of default parameters for performance\n  const isStrict: boolean = !!(options && options.isStrict);\n  const realm: FastCopy.Realm = (options && options.realm) || GLOBAL_THIS;\n\n  const getObjectClone: FastCopy.ObjectCloner = isStrict\n    ? getObjectCloneStrict\n    : getObjectCloneLoose;\n\n  /**\n   * @function handleCopy\n   *\n   * @description\n   * copy the object recursively based on its type\n   *\n   * @param object the object to copy\n   * @returns the copied object\n   */\n  const handleCopy: FastCopy.Copier = (object: any, cache: FastCopy.Cache): any => {\n    if (!object || typeof object !== 'object') {\n      return object;\n    } if (cache.has(object)) {\n      return cache.get(object);\n    }\n\n    const { constructor: Constructor } = object;\n\n    // plain objects\n    if (Constructor === realm.Object) {\n      return getObjectClone(object, realm, handleCopy, cache);\n    }\n\n    let clone: any;\n    // arrays\n    if (isArray(object)) {\n      // if strict, include non-standard properties\n      if (isStrict) {\n        return getObjectCloneStrict(object, realm, handleCopy, cache);\n      }\n\n      const { length } = object;\n\n      clone = new Constructor();\n      cache.set(object, clone);\n\n      for (let index: number = 0; index < length; index++) {\n        clone[index] = handleCopy(object[index], cache);\n      }\n\n      return clone;\n    }\n\n    // dates\n    if (object instanceof realm.Date) {\n      return new Constructor(object.getTime());\n    }\n\n    // regexps\n    if (object instanceof realm.RegExp) {\n      clone = new Constructor(object.source, object.flags || getRegExpFlags(object));\n\n      clone.lastIndex = object.lastIndex;\n\n      return clone;\n    }\n\n    // maps\n    if (realm.Map && object instanceof realm.Map) {\n      clone = new Constructor();\n      cache.set(object, clone);\n\n      object.forEach((value: any, key: any) => {\n        clone.set(key, handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // sets\n    if (realm.Set && object instanceof realm.Set) {\n      clone = new Constructor();\n      cache.set(object, clone);\n\n      object.forEach((value: any) => {\n        clone.add(handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // blobs\n    if (realm.Blob && object instanceof realm.Blob) {\n      return object.slice(0, object.size, object.type);\n    }\n\n    // buffers (node-only)\n    if (realm.Buffer && realm.Buffer.isBuffer(object)) {\n      clone = realm.Buffer.allocUnsafe\n        ? realm.Buffer.allocUnsafe(object.length)\n        : new Constructor(object.length);\n\n      cache.set(object, clone);\n      object.copy(clone);\n\n      return clone;\n    }\n\n    // arraybuffers / dataviews\n    if (realm.ArrayBuffer) {\n      // dataviews\n      if (realm.ArrayBuffer.isView(object)) {\n        clone = new Constructor(object.buffer.slice(0));\n        cache.set(object, clone);\n        return clone;\n      }\n\n      // arraybuffers\n      if (object instanceof realm.ArrayBuffer) {\n        clone = object.slice(0);\n        cache.set(object, clone);\n        return clone;\n      }\n    }\n\n    // if the object cannot / should not be cloned, don't\n    if (\n      // promise-like\n      typeof object.then === 'function' ||\n      // errors\n      object instanceof Error ||\n      // weakmaps\n      (realm.WeakMap && object instanceof realm.WeakMap) ||\n      // weaksets\n      (realm.WeakSet && object instanceof realm.WeakSet)\n    ) {\n      return object;\n    }\n\n    // assume anything left is a custom constructor\n    return getObjectClone(object, realm, handleCopy, cache);\n  };\n\n  return handleCopy(object, createCache());\n}\n\n// Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n// expects there to be a default property on the exported object. See\n// [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\ncopy.default = copy;\n\n/**\n * @function strictCopy\n *\n * @description\n * copy the object with `strict` option pre-applied\n *\n * @param object the object to copy\n * @param [options] the options for copying with\n * @param [options.realm] the realm (this) object the object is copied from\n * @returns the copied object\n */\ncopy.strict = function strictCopy(object: any, options?: FastCopy.Options) {\n  return copy(object, {\n    isStrict: true,\n    realm: options ? options.realm : void 0,\n  });\n};\n\nexport default copy;\n"]},"metadata":{},"sourceType":"script"}